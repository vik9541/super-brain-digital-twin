# ğŸ“Š PHASE 13: ADVANCED ANALYTICS
## ĞŸĞĞ›ĞĞĞ• Ğ¢Ğ•Ğ¥ĞĞ˜Ğ§Ğ•Ğ¡ĞšĞĞ• Ğ—ĞĞ”ĞĞĞ˜Ğ•

**Ğ”Ğ°Ñ‚Ğ° Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ°:** 13 Ğ´ĞµĞºĞ°Ğ±Ñ€Ñ 2025, 14:20 MSK  
**Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:** ğŸ¯ READY TO START  
**Ğ’Ñ€ĞµĞ¼Ñ Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸:** 3-5 Ğ´Ğ½ĞµĞ¹  
**ĞĞ¶Ğ¸Ğ´Ğ°ĞµĞ¼Ñ‹Ğ¹ Ğ¿Ñ€Ğ¸Ñ€Ğ¾ÑÑ‚:** +$30K-50K Ğ²Ğ°Ğ»ÑƒĞ°Ñ†Ğ¸Ğ¸  
**Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ Ğ²Ğ°Ğ»ÑƒĞ°Ñ†Ğ¸Ñ:** $480K-950K ğŸ’  
**Pattern Reuse:** 70%+ Ğ¾Ñ‚ Ğ¿Ñ€ĞµĞ´Ñ‹Ğ´ÑƒÑ‰Ğ¸Ñ… Ñ„Ğ°Ğ·  

---

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                                            â•‘
â•‘              ğŸ“Š PHASE 13: ADVANCED ANALYTICS DASHBOARD ğŸ“Š                 â•‘
â•‘                                                                            â•‘
â•‘  ğŸ¯ Ğ¦Ğ•Ğ›Ğ¬: Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¼Ğ¾Ñ‰Ğ½ÑƒÑ Ğ°Ğ½Ğ°Ğ»Ğ¸Ñ‚Ğ¸ĞºÑƒ Ğ´Ğ»Ñ Ğ±Ğ¸Ğ·Ğ½ĞµÑ-Ğ¸Ğ½ÑĞ°Ğ¹Ñ‚Ğ¾Ğ²                  â•‘
â•‘                                                                            â•‘
â•‘  âœ¨ Ğ¤Ğ˜Ğ§Ğ˜:                                                                  â•‘
â•‘     â€¢ Dashboard Ñ KPIs Ğ¸ Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸ĞµĞ¹                                    â•‘
â•‘     â€¢ Contact insights (engagement score, health)                         â•‘
â•‘     â€¢ Activity tracking timeline                                          â•‘
â•‘     â€¢ Revenue forecasting                                                 â•‘
â•‘     â€¢ Real-time updates (WebSocket)                                       â•‘
â•‘                                                                            â•‘
â•‘  ğŸ’» ĞšĞĞ”: ~1,100 LOC                                                       â•‘
â•‘  âœ… Ğ¢Ğ•Ğ¡Ğ¢Ğ«: 10 unit tests                                                  â•‘
â•‘  ğŸ“š Ğ”ĞĞšĞ£ĞœĞ•ĞĞ¢ĞĞ¦Ğ˜Ğ¯: 8,000+ ÑĞ»Ğ¾Ğ²                                             â•‘
â•‘                                                                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

## ğŸ—ï¸ ĞĞ Ğ¥Ğ˜Ğ¢Ğ•ĞšĞ¢Ğ£Ğ Ğ PHASE 13

### 3-ÑĞ»Ğ¾Ğ¹Ğ½Ğ°Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   LAYER 1: FRONTEND (React)          â”‚
â”‚  (Dashboard + Charts)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Components:                           â”‚
â”‚ â”œâ”€ AnalyticsDashboard (400 LOC)      â”‚
â”‚ â”œâ”€ KPICards (150 LOC)                â”‚
â”‚ â”œâ”€ Charts (Line, Pie, Bar) (200 LOC)â”‚
â”‚ â”œâ”€ ContactInsights (150 LOC)         â”‚
â”‚ â””â”€ ActivityTimeline (100 LOC)        â”‚
â”‚                                       â”‚
â”‚ Libraries:                            â”‚
â”‚ â”œâ”€ react-chartjs-2 (charts)          â”‚
â”‚ â”œâ”€ recharts (alternative)            â”‚
â”‚ â””â”€ socket.io-client (real-time)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“â†“â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   LAYER 2: BACKEND (NestJS)          â”‚
â”‚  (Analytics Engine)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ AnalyticsModule:                      â”‚
â”‚ â”œâ”€ AnalyticsService (350 LOC)        â”‚
â”‚ â”‚  â”œâ”€ getDashboardKPIs()             â”‚
â”‚ â”‚  â”œâ”€ getContactInsights()           â”‚
â”‚ â”‚  â”œâ”€ getActivityTimeline()          â”‚
â”‚ â”‚  â””â”€ getRevenueForecast()           â”‚
â”‚ â”œâ”€ AnalyticsController (100 LOC)     â”‚
â”‚ â”‚  â”œâ”€ @Get /dashboard-kpis           â”‚
â”‚ â”‚  â”œâ”€ @Get /contact-insights/:id     â”‚
â”‚ â”‚  â”œâ”€ @Get /activity-timeline        â”‚
â”‚ â”‚  â””â”€ @Get /revenue-forecast         â”‚
â”‚ â””â”€ WebSocketGateway (100 LOC)        â”‚
â”‚    â””â”€ Real-time updates              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“â†“â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   LAYER 3: DATABASE (PostgreSQL)     â”‚
â”‚  (Ñ€Ğ°ÑÑˆĞ¸Ñ€ÑĞµĞ¼ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰ÑƒÑ)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Existing tables (Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼):         â”‚
â”‚ â”œâ”€ Contact                            â”‚
â”‚ â”œâ”€ Activity                           â”‚
â”‚ â”œâ”€ Deal                               â”‚
â”‚ â””â”€ User                               â”‚
â”‚                                       â”‚
â”‚ NEW tables:                           â”‚
â”‚ â”œâ”€ AnalyticsCache (ĞºÑÑˆ)              â”‚
â”‚ â”‚  â”œâ”€ userId                          â”‚
â”‚ â”‚  â”œâ”€ metricType                      â”‚
â”‚ â”‚  â”œâ”€ data (JSON)                     â”‚
â”‚ â”‚  â”œâ”€ expiresAt                       â”‚
â”‚ â”‚  â””â”€ createdAt                       â”‚
â”‚ â””â”€ AnalyticsEvent (ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ)          â”‚
â”‚    â”œâ”€ userId                          â”‚
â”‚    â”œâ”€ eventType                       â”‚
â”‚    â”œâ”€ metadata (JSON)                 â”‚
â”‚    â””â”€ timestamp                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’» BACKEND Ğ Ğ•ĞĞ›Ğ˜Ğ—ĞĞ¦Ğ˜Ğ¯

### 1. AnalyticsModule Setup

```typescript
// src/analytics/analytics.module.ts

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AnalyticsController } from './analytics.controller';
import { AnalyticsService } from './analytics.service';
import { AnalyticsGateway } from './analytics.gateway';
import { Contact } from '../contacts/entities/contact.entity';
import { Activity } from '../activities/entities/activity.entity';
import { Deal } from '../deals/entities/deal.entity';
import { AnalyticsCache } from './entities/analytics-cache.entity';
import { AnalyticsEvent } from './entities/analytics-event.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      Contact,
      Activity,
      Deal,
      AnalyticsCache,
      AnalyticsEvent
    ])
  ],
  controllers: [AnalyticsController],
  providers: [AnalyticsService, AnalyticsGateway],
  exports: [AnalyticsService]
})
export class AnalyticsModule {}
```

---

### 2. Database Entities

```typescript
// src/analytics/entities/analytics-cache.entity.ts

import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, Index } from 'typeorm';

@Entity('analytics_cache')
@Index(['userId', 'metricType'])
export class AnalyticsCache {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('uuid')
  userId: string;

  @Column()
  metricType: string; // 'dashboard_kpis', 'contact_insights', etc.

  @Column('jsonb')
  data: any;

  @Column('timestamp')
  expiresAt: Date;

  @CreateDateColumn()
  createdAt: Date;
}

// src/analytics/entities/analytics-event.entity.ts

import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, Index } from 'typeorm';

@Entity('analytics_events')
@Index(['userId', 'eventType', 'timestamp'])
export class AnalyticsEvent {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column('uuid')
  userId: string;

  @Column()
  eventType: string; // 'contact_added', 'deal_closed', etc.

  @Column('jsonb')
  metadata: any;

  @CreateDateColumn()
  timestamp: Date;
}
```

---

### 3. DTOs (Data Transfer Objects)

```typescript
// src/analytics/dto/dashboard-kpis.dto.ts

export class DashboardKPIsDto {
  totalContacts: number;
  activeContacts: number;
  newContactsThisWeek: number;
  newContactsThisMonth: number;
  conversionRate: number;
  trend: {
    contacts: number; // +5.2% vs last week
    activities: number;
    revenue: number;
  };
}

// src/analytics/dto/contact-insights.dto.ts

export class ContactInsightsDto {
  contactId: string;
  engagementScore: number; // 0-100
  healthScore: number; // 0-100
  lastContactDate: Date;
  daysSinceLastContact: number;
  interactionFrequency: number; // interactions per week
  totalActivities: number;
  activitiesByType: {
    email: number;
    call: number;
    meeting: number;
  };
  riskLevel: 'low' | 'medium' | 'high'; // risk of losing contact
}

// src/analytics/dto/activity-timeline.dto.ts

export class ActivityTimelineDto {
  activities: Array<{
    id: string;
    type: string;
    contactName: string;
    description: string;
    timestamp: Date;
    userId: string;
    userName: string;
  }>;
  totalCount: number;
  page: number;
  pageSize: number;
}

// src/analytics/dto/revenue-forecast.dto.ts

export class RevenueForecastDto {
  pipelineValue: number;
  expected30Days: number;
  expected60Days: number;
  expected90Days: number;
  winRate: number; // percentage
  averageDealSize: number;
  dealVelocity: number; // average days to close
  topDeals: Array<{
    id: string;
    name: string;
    value: number;
    probability: number;
    expectedCloseDate: Date;
  }>;
}

// src/analytics/dto/chart-data.dto.ts

export class ChartDataDto {
  contactsOverTime: {
    labels: string[]; // dates
    datasets: Array<{
      label: string;
      data: number[];
      borderColor: string;
      backgroundColor: string;
    }>;
  };
  
  contactsByCategory: {
    labels: string[];
    datasets: Array<{
      data: number[];
      backgroundColor: string[];
    }>;
  };
  
  activityByDay: {
    labels: string[];
    datasets: Array<{
      label: string;
      data: number[];
      backgroundColor: string;
    }>;
  };
  
  activityHeatmap: {
    data: Array<{
      day: number; // 0-6 (Sun-Sat)
      hour: number; // 0-23
      value: number; // activity count
    }>;
  };
}
```

---

### 4. AnalyticsService (350 LOC)

```typescript
// src/analytics/analytics.service.ts

import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between } from 'typeorm';
import { Contact } from '../contacts/entities/contact.entity';
import { Activity } from '../activities/entities/activity.entity';
import { Deal } from '../deals/entities/deal.entity';
import { AnalyticsCache } from './entities/analytics-cache.entity';
import { AnalyticsEvent } from './entities/analytics-event.entity';
import * as moment from 'moment';

@Injectable()
export class AnalyticsService {
  private readonly logger = new Logger(AnalyticsService.name);

  constructor(
    @InjectRepository(Contact)
    private contactRepo: Repository<Contact>,
    
    @InjectRepository(Activity)
    private activityRepo: Repository<Activity>,
    
    @InjectRepository(Deal)
    private dealRepo: Repository<Deal>,
    
    @InjectRepository(AnalyticsCache)
    private cacheRepo: Repository<AnalyticsCache>,
    
    @InjectRepository(AnalyticsEvent)
    private eventRepo: Repository<AnalyticsEvent>
  ) {}

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 1ï¸âƒ£ DASHBOARD KPIs
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async getDashboardKPIs(userId: string): Promise<DashboardKPIsDto> {
    this.logger.log(`Getting dashboard KPIs for user ${userId}`);

    // Check cache first
    const cached = await this.getFromCache(userId, 'dashboard_kpis');
    if (cached) {
      this.logger.log('Returning cached KPIs');
      return cached;
    }

    // Calculate KPIs
    const totalContacts = await this.contactRepo.count({
      where: { userId }
    });

    const activeContacts = await this.getActiveContactsCount(userId, 30);

    const newContactsThisWeek = await this.getNewContactsCount(userId, 7);
    const newContactsThisMonth = await this.getNewContactsCount(userId, 30);

    const conversionRate = await this.calculateConversionRate(userId);

    // Calculate trends
    const lastWeekContacts = await this.getNewContactsCount(userId, 14) - newContactsThisWeek;
    const contactsTrend = this.calculateTrend(newContactsThisWeek, lastWeekContacts);

    const kpis: DashboardKPIsDto = {
      totalContacts,
      activeContacts,
      newContactsThisWeek,
      newContactsThisMonth,
      conversionRate,
      trend: {
        contacts: contactsTrend,
        activities: await this.calculateActivitiesTrend(userId),
        revenue: await this.calculateRevenueTrend(userId)
      }
    };

    // Cache for 5 minutes
    await this.saveToCache(userId, 'dashboard_kpis', kpis, 5);

    return kpis;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 2ï¸âƒ£ CONTACT INSIGHTS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async getContactInsights(contactId: string): Promise<ContactInsightsDto> {
    this.logger.log(`Getting insights for contact ${contactId}`);

    const contact = await this.contactRepo.findOne({
      where: { id: contactId },
      relations: ['activities']
    });

    if (!contact) {
      throw new Error('Contact not found');
    }

    const activities = await this.activityRepo.find({
      where: { contactId },
      order: { createdAt: 'DESC' }
    });

    const engagementScore = this.calculateEngagementScore(activities);
    const healthScore = this.calculateHealthScore(contact, activities);

    const lastActivity = activities[0];
    const daysSinceLastContact = lastActivity
      ? moment().diff(moment(lastActivity.createdAt), 'days')
      : 999;

    const activitiesByType = {
      email: activities.filter(a => a.type === 'email').length,
      call: activities.filter(a => a.type === 'call').length,
      meeting: activities.filter(a => a.type === 'meeting').length
    };

    const interactionFrequency = activities.length / 12; // per week over 3 months

    const riskLevel = this.calculateRiskLevel(daysSinceLastContact, engagementScore);

    return {
      contactId,
      engagementScore,
      healthScore,
      lastContactDate: lastActivity?.createdAt,
      daysSinceLastContact,
      interactionFrequency,
      totalActivities: activities.length,
      activitiesByType,
      riskLevel
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 3ï¸âƒ£ ACTIVITY TIMELINE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async getActivityTimeline(
    userId: string,
    filters?: {
      contactId?: string;
      type?: string;
      startDate?: Date;
      endDate?: Date;
    },
    page = 1,
    pageSize = 50
  ): Promise<ActivityTimelineDto> {
    this.logger.log(`Getting activity timeline for user ${userId}`);

    const where: any = { userId };

    if (filters?.contactId) where.contactId = filters.contactId;
    if (filters?.type) where.type = filters.type;
    if (filters?.startDate && filters?.endDate) {
      where.createdAt = Between(filters.startDate, filters.endDate);
    }

    const [activities, totalCount] = await this.activityRepo.findAndCount({
      where,
      relations: ['contact', 'user'],
      order: { createdAt: 'DESC' },
      skip: (page - 1) * pageSize,
      take: pageSize
    });

    return {
      activities: activities.map(a => ({
        id: a.id,
        type: a.type,
        contactName: a.contact?.name || 'Unknown',
        description: a.description,
        timestamp: a.createdAt,
        userId: a.userId,
        userName: a.user?.name || 'Unknown'
      })),
      totalCount,
      page,
      pageSize
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 4ï¸âƒ£ REVENUE FORECASTING
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async getRevenueForecast(userId: string): Promise<RevenueForecastDto> {
    this.logger.log(`Getting revenue forecast for user ${userId}`);

    const openDeals = await this.dealRepo.find({
      where: { userId, status: 'open' },
      order: { value: 'DESC' }
    });

    const pipelineValue = openDeals.reduce((sum, deal) => sum + deal.value, 0);

    const expected30Days = await this.forecastRevenue(openDeals, 30);
    const expected60Days = await this.forecastRevenue(openDeals, 60);
    const expected90Days = await this.forecastRevenue(openDeals, 90);

    const winRate = await this.calculateWinRate(userId);
    const averageDealSize = await this.calculateAverageDealSize(userId);
    const dealVelocity = await this.calculateDealVelocity(userId);

    const topDeals = openDeals.slice(0, 5).map(deal => ({
      id: deal.id,
      name: deal.name,
      value: deal.value,
      probability: deal.probability || 50,
      expectedCloseDate: deal.expectedCloseDate
    }));

    return {
      pipelineValue,
      expected30Days,
      expected60Days,
      expected90Days,
      winRate,
      averageDealSize,
      dealVelocity,
      topDeals
    };
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 5ï¸âƒ£ CHART DATA
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  async getChartData(userId: string): Promise<ChartDataDto> {
    this.logger.log(`Getting chart data for user ${userId}`);

    // Check cache
    const cached = await this.getFromCache(userId, 'chart_data');
    if (cached) return cached;

    // Generate chart data
    const contactsOverTime = await this.getContactsOverTimeData(userId);
    const contactsByCategory = await this.getContactsByCategoryData(userId);
    const activityByDay = await this.getActivityByDayData(userId);
    const activityHeatmap = await this.getActivityHeatmapData(userId);

    const chartData: ChartDataDto = {
      contactsOverTime,
      contactsByCategory,
      activityByDay,
      activityHeatmap
    };

    // Cache for 10 minutes
    await this.saveToCache(userId, 'chart_data', chartData, 10);

    return chartData;
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // ğŸ”§ HELPER METHODS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  private async getActiveContactsCount(userId: string, days: number): Promise<number> {
    const since = moment().subtract(days, 'days').toDate();

    return await this.activityRepo
      .createQueryBuilder('activity')
      .select('COUNT(DISTINCT activity.contactId)', 'count')
      .where('activity.userId = :userId', { userId })
      .andWhere('activity.createdAt >= :since', { since })
      .getRawOne()
      .then(result => parseInt(result.count));
  }

  private async getNewContactsCount(userId: string, days: number): Promise<number> {
    const since = moment().subtract(days, 'days').toDate();

    return await this.contactRepo.count({
      where: {
        userId,
        createdAt: Between(since, new Date())
      }
    });
  }

  private async calculateConversionRate(userId: string): Promise<number> {
    const totalContacts = await this.contactRepo.count({ where: { userId } });
    const convertedContacts = await this.dealRepo.count({
      where: { userId, status: 'closed_won' }
    });

    return totalContacts > 0 ? (convertedContacts / totalContacts) * 100 : 0;
  }

  private calculateTrend(current: number, previous: number): number {
    if (previous === 0) return current > 0 ? 100 : 0;
    return ((current - previous) / previous) * 100;
  }

  private calculateEngagementScore(activities: Activity[]): number {
    let score = 0;
    const now = new Date();

    activities.forEach(activity => {
      const daysSince = moment(now).diff(moment(activity.createdAt), 'days');
      const weight = Math.max(0, 1 - daysSince / 90); // decay over 90 days

      switch (activity.type) {
        case 'email':
          score += 1 * weight;
          break;
        case 'call':
          score += 3 * weight;
          break;
        case 'meeting':
          score += 5 * weight;
          break;
        default:
          score += 1 * weight;
      }
    });

    return Math.min(100, Math.round(score));
  }

  private calculateHealthScore(contact: Contact, activities: Activity[]): number {
    const engagementScore = this.calculateEngagementScore(activities);
    const recencyScore = this.calculateRecencyScore(activities);
    const completenessScore = this.calculateCompletenessScore(contact);

    return Math.round((engagementScore * 0.4 + recencyScore * 0.3 + completenessScore * 0.3));
  }

  private calculateRecencyScore(activities: Activity[]): number {
    if (activities.length === 0) return 0;

    const lastActivity = activities[0];
    const daysSince = moment().diff(moment(lastActivity.createdAt), 'days');

    if (daysSince <= 7) return 100;
    if (daysSince <= 30) return 70;
    if (daysSince <= 90) return 40;
    return 10;
  }

  private calculateCompletenessScore(contact: Contact): number {
    let score = 0;
    const fields = ['email', 'phone', 'company', 'jobTitle', 'website'];

    fields.forEach(field => {
      if (contact[field]) score += 20;
    });

    return score;
  }

  private calculateRiskLevel(
    daysSinceLastContact: number,
    engagementScore: number
  ): 'low' | 'medium' | 'high' {
    if (daysSinceLastContact > 90 || engagementScore < 30) return 'high';
    if (daysSinceLastContact > 30 || engagementScore < 60) return 'medium';
    return 'low';
  }

  private async forecastRevenue(deals: Deal[], days: number): Promise<number> {
    const targetDate = moment().add(days, 'days').toDate();

    const relevantDeals = deals.filter(deal =>
      deal.expectedCloseDate && moment(deal.expectedCloseDate).isBefore(targetDate)
    );

    return relevantDeals.reduce((sum, deal) => {
      const probability = (deal.probability || 50) / 100;
      return sum + deal.value * probability;
    }, 0);
  }

  private async calculateWinRate(userId: string): Promise<number> {
    const closedDeals = await this.dealRepo.count({
      where: [{ userId, status: 'closed_won' }, { userId, status: 'closed_lost' }]
    });

    const wonDeals = await this.dealRepo.count({
      where: { userId, status: 'closed_won' }
    });

    return closedDeals > 0 ? (wonDeals / closedDeals) * 100 : 0;
  }

  private async calculateAverageDealSize(userId: string): Promise<number> {
    const result = await this.dealRepo
      .createQueryBuilder('deal')
      .select('AVG(deal.value)', 'avg')
      .where('deal.userId = :userId', { userId })
      .andWhere('deal.status = :status', { status: 'closed_won' })
      .getRawOne();

    return parseFloat(result.avg) || 0;
  }

  private async calculateDealVelocity(userId: string): Promise<number> {
    const closedDeals = await this.dealRepo.find({
      where: [{ userId, status: 'closed_won' }, { userId, status: 'closed_lost' }]
    });

    if (closedDeals.length === 0) return 0;

    const totalDays = closedDeals.reduce((sum, deal) => {
      const days = moment(deal.updatedAt).diff(moment(deal.createdAt), 'days');
      return sum + days;
    }, 0);

    return totalDays / closedDeals.length;
  }

  private async getContactsOverTimeData(userId: string) {
    const last30Days = Array.from({ length: 30 }, (_, i) =>
      moment().subtract(29 - i, 'days').format('MM/DD')
    );

    const counts = await Promise.all(
      last30Days.map(async (date, index) => {
        const startDate = moment().subtract(29 - index, 'days').startOf('day').toDate();
        const endDate = moment().subtract(29 - index, 'days').endOf('day').toDate();

        return await this.contactRepo.count({
          where: {
            userId,
            createdAt: Between(startDate, endDate)
          }
        });
      })
    );

    return {
      labels: last30Days,
      datasets: [
        {
          label: 'New Contacts',
          data: counts,
          borderColor: 'rgb(75, 192, 192)',
          backgroundColor: 'rgba(75, 192, 192, 0.2)'
        }
      ]
    };
  }

  private async getContactsByCategoryData(userId: string) {
    const categories = await this.contactRepo
      .createQueryBuilder('contact')
      .select('contact.category', 'category')
      .addSelect('COUNT(*)', 'count')
      .where('contact.userId = :userId', { userId })
      .groupBy('contact.category')
      .getRawMany();

    return {
      labels: categories.map(c => c.category || 'Uncategorized'),
      datasets: [
        {
          data: categories.map(c => parseInt(c.count)),
          backgroundColor: [
            '#FF6384',
            '#36A2EB',
            '#FFCE56',
            '#4BC0C0',
            '#9966FF',
            '#FF9F40'
          ]
        }
      ]
    };
  }

  private async getActivityByDayData(userId: string) {
    const last7Days = Array.from({ length: 7 }, (_, i) =>
      moment().subtract(6 - i, 'days').format('ddd')
    );

    const counts = await Promise.all(
      last7Days.map(async (_, index) => {
        const startDate = moment().subtract(6 - index, 'days').startOf('day').toDate();
        const endDate = moment().subtract(6 - index, 'days').endOf('day').toDate();

        return await this.activityRepo.count({
          where: {
            userId,
            createdAt: Between(startDate, endDate)
          }
        });
      })
    );

    return {
      labels: last7Days,
      datasets: [
        {
          label: 'Activities',
          data: counts,
          backgroundColor: 'rgba(54, 162, 235, 0.5)'
        }
      ]
    };
  }

  private async getActivityHeatmapData(userId: string) {
    const last30Days = moment().subtract(30, 'days').toDate();

    const activities = await this.activityRepo.find({
      where: {
        userId,
        createdAt: Between(last30Days, new Date())
      },
      select: ['createdAt']
    });

    const heatmapData = [];

    for (let day = 0; day < 7; day++) {
      for (let hour = 0; hour < 24; hour++) {
        const count = activities.filter(a => {
          const activityDay = moment(a.createdAt).day();
          const activityHour = moment(a.createdAt).hour();
          return activityDay === day && activityHour === hour;
        }).length;

        heatmapData.push({ day, hour, value: count });
      }
    }

    return { data: heatmapData };
  }

  // Cache helpers
  private async getFromCache(userId: string, metricType: string): Promise<any> {
    const cached = await this.cacheRepo.findOne({
      where: { userId, metricType }
    });

    if (!cached) return null;

    if (moment().isAfter(cached.expiresAt)) {
      await this.cacheRepo.delete(cached.id);
      return null;
    }

    return cached.data;
  }

  private async saveToCache(
    userId: string,
    metricType: string,
    data: any,
    expiresInMinutes: number
  ): Promise<void> {
    const expiresAt = moment().add(expiresInMinutes, 'minutes').toDate();

    await this.cacheRepo.upsert(
      {
        userId,
        metricType,
        data,
        expiresAt,
        createdAt: new Date()
      },
      ['userId', 'metricType']
    );
  }

  // Activity trend calculation
  private async calculateActivitiesTrend(userId: string): Promise<number> {
    const thisWeek = await this.activityRepo.count({
      where: {
        userId,
        createdAt: Between(moment().subtract(7, 'days').toDate(), new Date())
      }
    });

    const lastWeek = await this.activityRepo.count({
      where: {
        userId,
        createdAt: Between(
          moment().subtract(14, 'days').toDate(),
          moment().subtract(7, 'days').toDate()
        )
      }
    });

    return this.calculateTrend(thisWeek, lastWeek);
  }

  // Revenue trend calculation
  private async calculateRevenueTrend(userId: string): Promise<number> {
    const thisMonth = await this.dealRepo
      .createQueryBuilder('deal')
      .select('SUM(deal.value)', 'sum')
      .where('deal.userId = :userId', { userId })
      .andWhere('deal.status = :status', { status: 'closed_won' })
      .andWhere('deal.updatedAt >= :since', {
        since: moment().subtract(30, 'days').toDate()
      })
      .getRawOne()
      .then(result => parseFloat(result.sum) || 0);

    const lastMonth = await this.dealRepo
      .createQueryBuilder('deal')
      .select('SUM(deal.value)', 'sum')
      .where('deal.userId = :userId', { userId })
      .andWhere('deal.status = :status', { status: 'closed_won' })
      .andWhere('deal.updatedAt >= :since', {
        since: moment().subtract(60, 'days').toDate()
      })
      .andWhere('deal.updatedAt < :before', {
        before: moment().subtract(30, 'days').toDate()
      })
      .getRawOne()
      .then(result => parseFloat(result.sum) || 0);

    return this.calculateTrend(thisMonth, lastMonth);
  }
}
```

---

### 5. AnalyticsController (100 LOC)

```typescript
// src/analytics/analytics.controller.ts

import { Controller, Get, Param, Query, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from '../auth/jwt-auth.guard';
import { CurrentUser } from '../auth/current-user.decorator';
import { AnalyticsService } from './analytics.service';

@Controller('api/analytics')
@UseGuards(JwtAuthGuard)
export class AnalyticsController {
  constructor(private readonly analyticsService: AnalyticsService) {}

  @Get('dashboard-kpis')
  async getDashboardKPIs(@CurrentUser() user: any) {
    return await this.analyticsService.getDashboardKPIs(user.id);
  }

  @Get('contact-insights/:id')
  async getContactInsights(@Param('id') contactId: string) {
    return await this.analyticsService.getContactInsights(contactId);
  }

  @Get('activity-timeline')
  async getActivityTimeline(
    @CurrentUser() user: any,
    @Query('contactId') contactId?: string,
    @Query('type') type?: string,
    @Query('startDate') startDate?: string,
    @Query('endDate') endDate?: string,
    @Query('page') page?: number,
    @Query('pageSize') pageSize?: number
  ) {
    const filters: any = {};
    if (contactId) filters.contactId = contactId;
    if (type) filters.type = type;
    if (startDate) filters.startDate = new Date(startDate);
    if (endDate) filters.endDate = new Date(endDate);

    return await this.analyticsService.getActivityTimeline(
      user.id,
      filters,
      page ? parseInt(page as any) : 1,
      pageSize ? parseInt(pageSize as any) : 50
    );
  }

  @Get('revenue-forecast')
  async getRevenueForecast(@CurrentUser() user: any) {
    return await this.analyticsService.getRevenueForecast(user.id);
  }

  @Get('chart-data')
  async getChartData(@CurrentUser() user: any) {
    return await this.analyticsService.getChartData(user.id);
  }
}
```

---

### 6. WebSocket Gateway (Real-time updates)

```typescript
// src/analytics/analytics.gateway.ts

import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  OnGatewayConnection,
  OnGatewayDisconnect
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger } from '@nestjs/common';

@WebSocketGateway({ cors: true, namespace: '/analytics' })
export class AnalyticsGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private logger = new Logger('AnalyticsGateway');
  private connectedClients: Map<string, string> = new Map(); // socketId -> userId

  handleConnection(client: Socket) {
    this.logger.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    this.logger.log(`Client disconnected: ${client.id}`);
    this.connectedClients.delete(client.id);
  }

  @SubscribeMessage('subscribe')
  handleSubscribe(client: Socket, payload: { userId: string }) {
    this.connectedClients.set(client.id, payload.userId);
    client.join(`user-${payload.userId}`);
    this.logger.log(`User ${payload.userId} subscribed to analytics updates`);
  }

  // Method to emit updates to specific user
  emitKPIUpdate(userId: string, kpis: any) {
    this.server.to(`user-${userId}`).emit('kpi-update', kpis);
  }

  // Method to emit activity updates
  emitActivityUpdate(userId: string, activity: any) {
    this.server.to(`user-${userId}`).emit('activity-update', activity);
  }
}
```

---

## ğŸ¨ FRONTEND Ğ Ğ•ĞĞ›Ğ˜Ğ—ĞĞ¦Ğ˜Ğ¯

### 1. AnalyticsDashboard Component

```typescript
// src/components/analytics/AnalyticsDashboard.tsx

import React, { useEffect, useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Line, Pie, Bar } from 'react-chartjs-2';
import io from 'socket.io-client';
import KPICards from './KPICards';
import ContactInsightsTable from './ContactInsightsTable';
import ActivityTimeline from './ActivityTimeline';
import RevenueForecast from './RevenueForecast';
import './AnalyticsDashboard.css';

const socket = io('http://localhost:3000/analytics', {
  auth: {
    token: localStorage.getItem('token')
  }
});

function AnalyticsDashboard() {
  const [kpis, setKpis] = useState(null);

  // Fetch dashboard KPIs
  const { data: initialKpis, isLoading } = useQuery(
    ['dashboard-kpis'],
    async () => {
      const response = await fetch('/api/analytics/dashboard-kpis', {
        headers: {
          Authorization: `Bearer ${localStorage.getItem('token')}`
        }
      });
      return response.json();
    },
    {
      refetchInterval: 60000 // refetch every minute
    }
  );

  // Fetch chart data
  const { data: chartData } = useQuery(
    ['chart-data'],
    async () => {
      const response = await fetch('/api/analytics/chart-data', {
        headers: {
          Authorization: `Bearer ${localStorage.getItem('token')}`
        }
      });
      return response.json();
    }
  );

  useEffect(() => {
    if (initialKpis) {
      setKpis(initialKpis);
    }
  }, [initialKpis]);

  // WebSocket real-time updates
  useEffect(() => {
    socket.emit('subscribe', { userId: 'current-user-id' });

    socket.on('kpi-update', (updatedKpis) => {
      setKpis(updatedKpis);
    });

    return () => {
      socket.off('kpi-update');
    };
  }, []);

  if (isLoading) {
    return <div className="loading">Loading analytics...</div>;
  }

  return (
    <div className="analytics-dashboard">
      <h1>Analytics Dashboard</h1>

      {/* KPI Cards */}
      <KPICards data={kpis} />

      {/* Charts Grid */}
      <div className="charts-grid">
        <div className="chart-card">
          <h3>Contacts Over Time</h3>
          {chartData?.contactsOverTime && (
            <Line
              data={chartData.contactsOverTime}
              options={{
                responsive: true,
                plugins: {
                  legend: { position: 'top' },
                  title: { display: false }
                }
              }}
            />
          )}
        </div>

        <div className="chart-card">
          <h3>Contacts by Category</h3>
          {chartData?.contactsByCategory && (
            <Pie
              data={chartData.contactsByCategory}
              options={{
                responsive: true,
                plugins: {
                  legend: { position: 'right' }
                }
              }}
            />
          )}
        </div>

        <div className="chart-card">
          <h3>Activity by Day</h3>
          {chartData?.activityByDay && (
            <Bar
              data={chartData.activityByDay}
              options={{
                responsive: true,
                scales: {
                  y: { beginAtZero: true }
                }
              }}
            />
          )}
        </div>

        <div className="chart-card heatmap">
          <h3>Activity Heatmap</h3>
          {chartData?.activityHeatmap && (
            <ActivityHeatmap data={chartData.activityHeatmap.data} />
          )}
        </div>
      </div>

      {/* Contact Insights Table */}
      <ContactInsightsTable />

      {/* Activity Timeline */}
      <ActivityTimeline />

      {/* Revenue Forecast */}
      <RevenueForecast />
    </div>
  );
}

export default AnalyticsDashboard;
```

---

### 2. KPICards Component

```typescript
// src/components/analytics/KPICards.tsx

import React from 'react';
import { TrendingUp, TrendingDown, Users, Activity, DollarSign } from 'lucide-react';
import './KPICards.css';

interface KPICardsProps {
  data: {
    totalContacts: number;
    activeContacts: number;
    newContactsThisWeek: number;
    conversionRate: number;
    trend: {
      contacts: number;
      activities: number;
      revenue: number;
    };
  };
}

function KPICards({ data }: KPICardsProps) {
  if (!data) return null;

  const kpis = [
    {
      title: 'Total Contacts',
      value: data.totalContacts.toLocaleString(),
      trend: data.trend.contacts,
      icon: <Users size={24} />,
      color: 'blue'
    },
    {
      title: 'Active Contacts',
      value: data.activeContacts.toLocaleString(),
      subtitle: 'Last 30 days',
      icon: <Activity size={24} />,
      color: 'green'
    },
    {
      title: 'New This Week',
      value: data.newContactsThisWeek.toLocaleString(),
      trend: data.trend.contacts,
      icon: <TrendingUp size={24} />,
      color: 'purple'
    },
    {
      title: 'Conversion Rate',
      value: `${data.conversionRate.toFixed(1)}%`,
      trend: data.trend.revenue,
      icon: <DollarSign size={24} />,
      color: 'orange'
    }
  ];

  return (
    <div className="kpi-cards">
      {kpis.map((kpi, index) => (
        <div key={index} className={`kpi-card ${kpi.color}`}>
          <div className="kpi-header">
            <span className="kpi-title">{kpi.title}</span>
            <div className="kpi-icon">{kpi.icon}</div>
          </div>
          <div className="kpi-value">{kpi.value}</div>
          {kpi.trend !== undefined && (
            <div className={`kpi-trend ${kpi.trend >= 0 ? 'positive' : 'negative'}`}>
              {kpi.trend >= 0 ? <TrendingUp size={16} /> : <TrendingDown size={16} />}
              <span>{Math.abs(kpi.trend).toFixed(1)}%</span>
            </div>
          )}
          {kpi.subtitle && <div className="kpi-subtitle">{kpi.subtitle}</div>}
        </div>
      ))}
    </div>
  );
}

export default KPICards;
```

---

### 3. CSS Styling

```css
/* src/components/analytics/AnalyticsDashboard.css */

.analytics-dashboard {
  padding: 24px;
  max-width: 1400px;
  margin: 0 auto;
}

.analytics-dashboard h1 {
  font-size: 32px;
  font-weight: 600;
  margin-bottom: 24px;
  color: #1a202c;
}

.kpi-cards {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  margin-bottom: 32px;
}

.kpi-card {
  background: white;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  transition: transform 0.2s, box-shadow 0.2s;
}

.kpi-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
}

.kpi-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.kpi-title {
  font-size: 14px;
  font-weight: 500;
  color: #64748b;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.kpi-icon {
  padding: 8px;
  border-radius: 8px;
  background: rgba(99, 102, 241, 0.1);
  color: #6366f1;
}

.kpi-card.blue .kpi-icon {
  background: rgba(59, 130, 246, 0.1);
  color: #3b82f6;
}

.kpi-card.green .kpi-icon {
  background: rgba(34, 197, 94, 0.1);
  color: #22c55e;
}

.kpi-card.purple .kpi-icon {
  background: rgba(168, 85, 247, 0.1);
  color: #a855f7;
}

.kpi-card.orange .kpi-icon {
  background: rgba(249, 115, 22, 0.1);
  color: #f97316;
}

.kpi-value {
  font-size: 36px;
  font-weight: 700;
  color: #1a202c;
  margin-bottom: 8px;
}

.kpi-trend {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 14px;
  font-weight: 600;
}

.kpi-trend.positive {
  color: #22c55e;
}

.kpi-trend.negative {
  color: #ef4444;
}

.kpi-subtitle {
  font-size: 12px;
  color: #94a3b8;
  margin-top: 4px;
}

.charts-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
  gap: 24px;
  margin-bottom: 32px;
}

.chart-card {
  background: white;
  border-radius: 12px;
  padding: 24px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.chart-card h3 {
  font-size: 18px;
  font-weight: 600;
  color: #1a202c;
  margin-bottom: 16px;
}

.chart-card.heatmap {
  grid-column: span 2;
}

.loading {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 400px;
  font-size: 18px;
  color: #64748b;
}

@media (max-width: 768px) {
  .kpi-cards {
    grid-template-columns: 1fr;
  }

  .charts-grid {
    grid-template-columns: 1fr;
  }

  .chart-card.heatmap {
    grid-column: span 1;
  }
}
```

---

## âœ… UNIT TESTS

```typescript
// src/analytics/analytics.service.spec.ts

import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { AnalyticsService } from './analytics.service';
import { Contact } from '../contacts/entities/contact.entity';
import { Activity } from '../activities/entities/activity.entity';
import { Deal } from '../deals/entities/deal.entity';
import { AnalyticsCache } from './entities/analytics-cache.entity';
import { AnalyticsEvent } from './entities/analytics-event.entity';

describe('AnalyticsService', () => {
  let service: AnalyticsService;
  let contactRepo: any;
  let activityRepo: any;
  let dealRepo: any;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AnalyticsService,
        {
          provide: getRepositoryToken(Contact),
          useValue: {
            count: jest.fn(),
            find: jest.fn(),
            findOne: jest.fn()
          }
        },
        {
          provide: getRepositoryToken(Activity),
          useValue: {
            count: jest.fn(),
            find: jest.fn(),
            createQueryBuilder: jest.fn()
          }
        },
        {
          provide: getRepositoryToken(Deal),
          useValue: {
            count: jest.fn(),
            find: jest.fn(),
            createQueryBuilder: jest.fn()
          }
        },
        {
          provide: getRepositoryToken(AnalyticsCache),
          useValue: {
            findOne: jest.fn(),
            upsert: jest.fn(),
            delete: jest.fn()
          }
        },
        {
          provide: getRepositoryToken(AnalyticsEvent),
          useValue: {}
        }
      ]
    }).compile();

    service = module.get<AnalyticsService>(AnalyticsService);
    contactRepo = module.get(getRepositoryToken(Contact));
    activityRepo = module.get(getRepositoryToken(Activity));
    dealRepo = module.get(getRepositoryToken(Deal));
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('getDashboardKPIs', () => {
    it('should return dashboard KPIs', async () => {
      contactRepo.count.mockResolvedValue(100);
      activityRepo.createQueryBuilder.mockReturnValue({
        select: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        andWhere: jest.fn().mockReturnThis(),
        getRawOne: jest.fn().mockResolvedValue({ count: '50' })
      });

      const kpis = await service.getDashboardKPIs('user-123');

      expect(kpis).toBeDefined();
      expect(kpis.totalContacts).toBe(100);
      expect(contactRepo.count).toHaveBeenCalled();
    });

    it('should use cached data if available', async () => {
      // Test caching logic
    });
  });

  describe('getContactInsights', () => {
    it('should return contact insights', async () => {
      const mockContact = {
        id: 'contact-123',
        name: 'John Doe',
        email: 'john@example.com'
      };

      const mockActivities = [
        { type: 'email', createdAt: new Date() },
        { type: 'call', createdAt: new Date() }
      ];

      contactRepo.findOne.mockResolvedValue(mockContact);
      activityRepo.find.mockResolvedValue(mockActivities);

      const insights = await service.getContactInsights('contact-123');

      expect(insights).toBeDefined();
      expect(insights.contactId).toBe('contact-123');
      expect(insights.totalActivities).toBe(2);
    });

    it('should throw error if contact not found', async () => {
      contactRepo.findOne.mockResolvedValue(null);

      await expect(service.getContactInsights('invalid-id')).rejects.toThrow(
        'Contact not found'
      );
    });
  });

  describe('getActivityTimeline', () => {
    it('should return paginated activities', async () => {
      // Test implementation
    });

    it('should filter by contact', async () => {
      // Test implementation
    });

    it('should filter by date range', async () => {
      // Test implementation
    });
  });

  describe('getRevenueForecast', () => {
    it('should calculate revenue forecast', async () => {
      // Test implementation
    });

    it('should calculate win rate correctly', async () => {
      // Test implementation
    });
  });

  describe('getChartData', () => {
    it('should return chart data', async () => {
      // Test implementation
    });
  });
});
```

---

## ğŸ“‹ IMPLEMENTATION CHECKLIST

### Day 1: Backend Setup (6 hours)

```
[ ] 1. Create AnalyticsModule (30 min)
    â”œâ”€ Generate module: nest g module analytics
    â”œâ”€ Generate service: nest g service analytics
    â”œâ”€ Generate controller: nest g controller analytics
    â””â”€ Import required modules

[ ] 2. Create Database Entities (1 hour)
    â”œâ”€ AnalyticsCache entity
    â”œâ”€ AnalyticsEvent entity
    â””â”€ Run migration: npm run migration:generate

[ ] 3. Create DTOs (1 hour)
    â”œâ”€ DashboardKPIsDto
    â”œâ”€ ContactInsightsDto
    â”œâ”€ ActivityTimelineDto
    â”œâ”€ RevenueForecastDto
    â””â”€ ChartDataDto

[ ] 4. Implement AnalyticsService - Part 1 (3.5 hours)
    â”œâ”€ getDashboardKPIs() (1 hour)
    â”œâ”€ getContactInsights() (1 hour)
    â”œâ”€ Helper methods (1.5 hours)
    â”‚  â”œâ”€ calculateEngagementScore()
    â”‚  â”œâ”€ calculateHealthScore()
    â”‚  â”œâ”€ calculateTrend()
    â”‚  â””â”€ Cache helpers
    â””â”€ Test basic functionality
```

### Day 2: Backend - Part 2 (6 hours)

```
[ ] 5. Implement AnalyticsService - Part 2 (4 hours)
    â”œâ”€ getActivityTimeline() (1 hour)
    â”œâ”€ getRevenueForecast() (1.5 hours)
    â”œâ”€ getChartData() (1.5 hours)
    â””â”€ Chart data generation methods

[ ] 6. Implement AnalyticsController (1 hour)
    â”œâ”€ All GET endpoints
    â”œâ”€ Query parameter handling
    â””â”€ Error handling

[ ] 7. Implement WebSocketGateway (1 hour)
    â”œâ”€ Connection handling
    â”œâ”€ Subscribe/unsubscribe
    â””â”€ Real-time emit methods
```

### Day 3: Testing (6 hours)

```
[ ] 8. Unit Tests (3 hours)
    â”œâ”€ AnalyticsService tests (10 tests)
    â”œâ”€ Mock repositories
    â””â”€ All tests passing âœ…

[ ] 9. Integration Tests (2 hours)
    â”œâ”€ E2E: Get dashboard KPIs
    â”œâ”€ E2E: Get contact insights
    â”œâ”€ E2E: Activity timeline
    â””â”€ E2E: Revenue forecast

[ ] 10. Performance Testing (1 hour)
     â”œâ”€ Test with 1000+ contacts
     â”œâ”€ Test with 10000+ activities
     â”œâ”€ Verify caching works
     â””â”€ Response time < 500ms âœ…
```

### Day 4: Frontend (6 hours)

```
[ ] 11. Setup Frontend Dependencies (30 min)
     â”œâ”€ npm install react-chartjs-2 chart.js
     â”œâ”€ npm install socket.io-client
     â”œâ”€ npm install @tanstack/react-query
     â””â”€ npm install lucide-react

[ ] 12. Create Dashboard Component (2 hours)
     â”œâ”€ AnalyticsDashboard.tsx
     â”œâ”€ Fetch KPIs
     â”œâ”€ Fetch chart data
     â””â”€ WebSocket connection

[ ] 13. Create Sub-Components (2.5 hours)
     â”œâ”€ KPICards.tsx (1 hour)
     â”œâ”€ Chart components (1 hour)
     â””â”€ ActivityHeatmap.tsx (30 min)

[ ] 14. Styling (1 hour)
     â”œâ”€ AnalyticsDashboard.css
     â”œâ”€ Responsive design
     â””â”€ Dark mode support (optional)
```

### Day 5: Polish & Deploy (5 hours)

```
[ ] 15. Additional Components (2 hours)
     â”œâ”€ ContactInsightsTable.tsx
     â”œâ”€ ActivityTimeline.tsx
     â””â”€ RevenueForecast.tsx

[ ] 16. Performance Optimization (1 hour)
     â”œâ”€ Lazy loading
     â”œâ”€ Memoization
     â””â”€ Code splitting

[ ] 17. Final Testing (1 hour)
     â”œâ”€ Manual QA
     â”œâ”€ Cross-browser testing
     â””â”€ Mobile responsiveness

[ ] 18. Documentation & Deployment (1 hour)
     â”œâ”€ Update README
     â”œâ”€ API documentation
     â”œâ”€ Deploy to staging
     â””â”€ âœ… PHASE 13 COMPLETE!
```

---

## ğŸ“¦ DEPENDENCIES

### Backend:
```json
{
  "dependencies": {
    "@nestjs/common": "^10.0.0",
    "@nestjs/typeorm": "^10.0.0",
    "@nestjs/websockets": "^10.0.0",
    "@nestjs/platform-socket.io": "^10.0.0",
    "typeorm": "^0.3.0",
    "pg": "^8.11.0",
    "moment": "^2.29.4",
    "socket.io": "^4.6.0"
  }
}
```

### Frontend:
```json
{
  "dependencies": {
    "react": "^18.2.0",
    "react-chartjs-2": "^5.2.0",
    "chart.js": "^4.4.0",
    "@tanstack/react-query": "^5.0.0",
    "socket.io-client": "^4.6.0",
    "lucide-react": "^0.294.0"
  }
}
```

---

## ğŸ’ EXPECTED RESULTS

```
âœ… ĞšĞĞ”:
   â”œâ”€ Backend: 850 LOC
   â”œâ”€ Frontend: 800 LOC
   â”œâ”€ Tests: 10 unit tests
   â””â”€ Total: ~1,650 LOC

âœ… Ğ¤Ğ˜Ğ§Ğ˜:
   â”œâ”€ Dashboard Ñ 4 KPI cards
   â”œâ”€ 4 Ñ‚Ğ¸Ğ¿Ğ° charts (Line, Pie, Bar, Heatmap)
   â”œâ”€ Contact insights Ñ scoring
   â”œâ”€ Activity timeline Ñ filters
   â”œâ”€ Revenue forecasting
   â””â”€ Real-time updates (WebSocket)

âœ… ĞŸĞ ĞĞ˜Ğ—Ğ’ĞĞ”Ğ˜Ğ¢Ğ•Ğ›Ğ¬ĞĞĞ¡Ğ¢Ğ¬:
   â”œâ”€ Dashboard load: <1 sec
   â”œâ”€ Chart render: <500ms
   â”œâ”€ Real-time latency: <100ms
   â””â”€ Cache hit rate: >80%

âœ… Ğ’ĞĞ›Ğ£ĞĞ¦Ğ˜Ğ¯:
   â”œâ”€ ĞŸÑ€Ğ¸Ñ€Ğ¾ÑÑ‚: +$30K-50K
   â”œâ”€ Ğ¤Ğ¸Ğ½Ğ°Ğ»ÑŒĞ½Ğ°Ñ: $480K-950K
   â””â”€ ROI: 5-10x
```

---

## ğŸš€ QUICK START

```bash
# 1. Install dependencies
npm install

# 2. Generate migration
npm run migration:generate -- -n AddAnalytics

# 3. Run migration
npm run migration:run

# 4. Start development
npm run start:dev

# 5. Run tests
npm run test

# 6. Frontend (separate terminal)
cd frontend
npm install
npm run dev
```

---

**Status:** ğŸ¯ READY TO START  
**Timeline:** 3-5 days  
**Expected:** +$30K-50K valuation  
**Quality:** Production-grade âœ…  

**LET'S BUILD PHASE 13!** ğŸš€ğŸ“ŠğŸ’
